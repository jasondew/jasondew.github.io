---
layout: post
title: Turing Machines explained from the ground up
date: '2012-05-07T06:16:00.000-07:00'
author: Jason Dew
tags: computer_science speaking
modified_time: '2016-07-10T18:55:57.279-07:00'
blogger_id: tag:blogger.com,1999:blog-7252006856404953359.post-1145134308214018034
blogger_orig_url: https://blog.jasondew.com/2012/05/turing-machines-explained-from-ground-up.html
---

<p>I gave a talk at <a href="http://convergese.org/">ConvergeSE 2012</a>&nbsp;on this topic so I thought I'd write it up as a blog post as well. That said, let's jump right in.</p><p><span style="font-size:medium;">Turing</span></p><p>So the obvious thing to start with is Alan Turing, the man for which Turing machines are named. Turing was a British&nbsp;mathematician&nbsp;sometimes called the "father of Computer Science." &nbsp;I call him a mathematician because he did computer science before there was a discipline so named. He was influential in several fields, including AI and cryptanalysis. Specifically, he worked at Bletchley Park during World War II where he worked on breaking communications encrypted by the German enigma. His first major achievement was a paper written in 1936, before he had obtained his Ph.D., proving that the Entscheidungsproblem had no solution.</p><p>The Entscheidungsproblem was proposed by a very famous mathematician named David Hilbert in 1928. Simply put, the question is whether or not an "algorithm" could be devised to determine if a statement in first-order logic is universally valid. To accomplish this, Turing devised a theoretical machine that he used to answer this question in the negative. The machine became known as a Turing machine.</p><p><span style="font-size:medium;">Background</span></p><p>In order to understand this machine, we need to start with some terminology. Most of these have roots in language, so they'll seem familiar. First, we have an <strong>alphabet</strong>. This is simpy a set of symbols. For example, we have the set of lowercase roman letters, denoted: {"a", "b", "c", ..., "z"}. Another example, that we'll use later, is the <strong>binary alphabet</strong>&nbsp;or {"0", "1"}. We can represent any number with just these two symbols.</p><p>The natural thing to do with a set is to combine the elements into a sequence of symbols. This construction is called a <strong>string</strong>. Some examples from the binary alphabet are "0", "0101001", and the empty string. So, to reiterate, zero or more symbols from an alphabet gets you a string.</p><p>Finally, a <strong>formal language</strong>&nbsp;is a set of strings "over" an alphabet. For example, we could define a formal language of metasyntactic variables: {"foo", "bar", "baz", "quux"}. The alphabet here is taken to be the lowercase roman letters, as before. Another example is the two-digit binary numbers: {"00", "01", "10", "11"}. Notice that both of these sets are finite but this doesn't have to be the case. Consider the alphabet {"a", "b"} and the formal language {"b", "ab", "aab", "aaab", ...} which is the set of zero of more "a"s followed by a single "b". You could write this more compactly as a*b but more on that later.</p><p><span style="font-size:medium;">Finite Automata</span></p><p>Now for the fun stuff: Deterministic Finite Automata, also known as DFAs or just finite state machines. These simple "machine"s are defined by an alphabet, a set of states, and a transition function. The alphabet defines the valid symbols that the machine can take as input. One of the states is defined as the <strong>start state</strong>&nbsp;and one or more are defined as <strong>accepting states</strong>. The starting state is pretty obvious, it's just the initial state of the machine. The accepting states determine whether or not the machine "accepts" the input it was given. The most interesting part, though, is the transition function. It takes a symbol, from the input stream, and the current state the machine is in and returns the new state we will transition to. Here's a graphical representation of a DFA that accepts binary strings that are a multiple of 3:</p><p><span style="font-family:Times;font-size:small;"><strong><div class='p_embed p_image_embed'><img alt="500px-dfa_example_multiplies_of_3" height="213" src="http://jasondew.files.wordpress.com/2012/05/500px-dfa_example_multiplies_of_3-svg-scaled500.png" width="500" /></div></strong></span></p><p>The notation requires some explanation. The circled values represent states with the start state denoted by an arrow pointing to it and the accepting states denoted with double circles. The arrows leaving and entering the states are the transition. Taken all together, they define the transition function for this DFA. The arrow from state S_0 to S_1 with the label "1" means that if we are in state S_0 and we read a "1" on the input stream then we should transition to state S_2. Furthermore, just from the diagram we can infer that the alphabet here is {"0", "1"}. This is because DFAs must have a leaving arrow for each symbol on each state. This is the deterministic property.</p><p>It will really help cement the concept if you run through a few examples. Consider the input "00". We start at state S_0 and see a "0" so we stay in the same state. When we see the second "0", we again transition to state S_0. Since we're out of input at this point, we consider whether or not we're in an accepting state. It turns out we are, which means that the machine has accepted the input. In this case, the machine is saying that "00" (0 in decimal) is a multiple of 3. Since 0*3=0, we can see this is true. Consider the input "1". In this case, we end up in state S_1 which is not an accepting state. Therefore, the machine rejects that input. This makes sense because there is no (integer) value such that x * 3 = 1.</p><p>Now, consider what would happen if we relax the deterministic constraint. This would mean that the transition function can now return zero or more states. In other words, we can have no transition out of a state at all (a sink), a single transition (as before), or multiple transitions. In the final case, we're effectively allowing the machine to split itself into how ever many transitions there are. This effective gives us a tree of automata. Obviously, this gives us quite a bit more expressive power.</p><p>These machines are called nondeterministic finite automata or NFAs. Lets look at an example:</p><p><div class='p_embed p_image_embed'><img alt="500px-nfasimpleexample" height="273" src="http://jasondew.files.wordpress.com/2012/05/500px-nfasimpleexample-svg-scaled500.png" width="500" /></div></p><p>This machine is using the same alphabet as before and has only two states, p and q. Here, the starting state is p and q is the only accepting state. Notice that when in state p and seeing a "1", we simultaneously stay in the p state and also move to the q state. You can think of this as multiple universes or cloning the machine so that we keep track of all possible paths. It turns out that this machine accepts any binary string that ends with a "1".</p><p>Surprisingly, NFAs and DFAs are equivalent in expressive power. That is, any NFA can be converted into a DFA that accepts the same string. So even though we allow non-determinism, we can still convert it into an equivalent, but generally larger, DFA.</p><p><span style="font-size:medium;">Regular languages</span></p><p>The set of strings that a finite automaton accepts is called it's language. Conversely, a <strong>regular language</strong>&nbsp;is any language that can be recognized by a finite automaton, either deterministic or not. Even more interesting is that a language is regular if and only if some <strong>regular expression</strong>&nbsp;describes it. What this means is that regular expressions and DFAs have the same capability in describing languages. So we can convert from a DFA into a regular expression and vice versa.</p><p><span style="font-size:medium;">Turing Machines</span></p><p>Finally we're ready to describe Turing Machines. They are just a small step up in complexity from the finite automata we just looked at. We now have a name for the stream of input, the tape. Turing machines can read/write to/from the tape as well as control it's movement. So, now we need two alphabets: the input alphabet and the output (or tape) alphabet. We still have a set of states, except that now we will have one starting state, one accepting state, and one rejecting state. There will still be a transition function, except that now it takes a state and a symbol from the current position on the tape and returns a new state, possibly a symbol to write, and a direction to move (either left or right). Notice that we don't have to write a symbol, but we do have to move.</p><p>Lets look at an example Turing Machine. We'll name it M for machine. It's going to have an input alphabet of {"0"} and a tape alphabet of {"_", "x"}. The machine will accept "0" strings whose length is a power of 2. That is, string's whose length can be expressed as 2^x for some integer x. For example, "0", "00", and "0000" are the smallest strings that should be accepted because they are of length 1 (2^0), 2 (2^1), and 4 (2^2), respectively. To be clear, the machine would reject strings like "000" and "00000".</p><p><div class='p_embed p_image_embed'><a href="http://jasondew.files.wordpress.com/2012/05/screen_shot_2012-05-04_at_10-25-58_pm-scaled1000.png"><img alt="Screen_shot_2012-05-04_at_10" height="296" src="http://jasondew.files.wordpress.com/2012/05/screen_shot_2012-05-04_at_10-25-58_pm-scaled1000.png?w=300" width="500" /></a></div></p><p>This description should look familiar. The labels on the transition arrows has gotten a little more interesting. They are in the form "symbol -&gt; [symbol,] direction" where the first symbol defines when this transition is applicable, the second symbol is optional and defines the symbol to write to the tape, and the direction is either L or R for moving the left or right on the tape.</p><p>So if we imagine the tape with a "." at the current position, the transition of states for the input "00" goes something like this:</p><p><div class='p_embed p_image_embed'><img alt="Screen_shot_2012-05-04_at_10" height="372" src="http://jasondew.files.wordpress.com/2012/05/screen_shot_2012-05-04_at_10-31-26_pm-scaled500.png" width="175" /></div></p><p>You should try "running" the machine on other inputs, making a table similar to the one above. Basically, the procedure is to mark off half of the 0s on each pass. If we run out of zeros during the intermediate stage, then we know we should reject. Otherwise, we accept the string.</p><p>Once you get comfortable with what this machine is doing, you'll notice that each state has a specific purpose. For example, the state q1 marks the first 0 with an _ so that it knows when we're at the beginning of the string. States q2, q3, and q4 are doing the builk of the work, marking through the "0"s with "x"s and moving the tape. State q5 is a reset procedure, moving us back to the beginning of the input.</p><p><span style="font-size:medium;">Conclusion</span></p><p><span style="font-size:medium;"><span style="font-size:small;">So why do we care about Turing machines? First of all, they define what an algorithm is, in more concrete terms. This is relatd to the Church-Turing thesis and what it means to be "computable." It also turns out that they are equivalent in power to any other reasonable computational model. This is fairly surprising considering how relatively simple they are. They represent the essence of what it is to be a "computer."</span></span></p><p><span style="font-size:medium;"><span style="font-size:small;"><br /></span></span></p><p><span style="font-size:medium;">References</span></p><p><span style="font-size:x-small;"><strong style="font-family:Times;font-size:medium;"><span style="font-family:Times New Roman;background-color:transparent;font-weight:normal;font-style:italic;vertical-align:baseline;">Deterministic finite automaton</span><span style="font-family:Times New Roman;background-color:transparent;font-weight:normal;vertical-align:baseline;">. (2012, March 11). Retrieved from <a href="http://en.wikipedia.org/wiki/Deterministic_finite_automaton">http://en.wikipedia.org/wiki/Deterministic_finite_automaton</a></span><br /><span style="font-family:Times New Roman;background-color:transparent;font-weight:normal;vertical-align:baseline;">&nbsp;</span><br /><span style="font-family:Times New Roman;background-color:transparent;font-weight:normal;font-style:italic;vertical-align:baseline;">Nondeterministic finite automaton</span><span style="font-family:Times New Roman;background-color:transparent;font-weight:normal;vertical-align:baseline;">. (2012, April 20). Retrieved from <a href="http://en.wikipedia.org/wiki/Nondeterministic_finite_automaton">http://en.wikipedia.org/wiki/Nondeterministic_finite_automaton</a></span><p /><span style="font-family:Times New Roman;background-color:transparent;font-weight:normal;vertical-align:baseline;">Petzold, C. (2008). </span><span style="font-family:Times New Roman;background-color:transparent;font-weight:normal;font-style:italic;vertical-align:baseline;">The annotated turing</span><span style="font-family:Times New Roman;background-color:transparent;font-weight:normal;vertical-align:baseline;">. Indianapolis: Wiley Publishing, Inc.</span><p /><span style="font-family:Times New Roman;background-color:transparent;font-weight:normal;vertical-align:baseline;">Sipser, M. (2006). </span><span style="font-family:Times New Roman;background-color:transparent;font-weight:normal;font-style:italic;vertical-align:baseline;">Introduction to the theory of computation</span><span style="font-family:Times New Roman;background-color:transparent;font-weight:normal;vertical-align:baseline;">. (2nd ed.). Boston: Thompson Course Technology.</span><p /><span style="font-family:Times New Roman;background-color:transparent;font-weight:normal;font-style:italic;vertical-align:baseline;">Turing machine</span><span style="font-family:Times New Roman;background-color:transparent;font-weight:normal;vertical-align:baseline;">. (2012, April 17). Retrieved from <a href="http://en.wikipedia.org/wiki/Turing_machine">http://en.wikipedia.org/wiki/Turing_machine</a></span></strong></span></p>
